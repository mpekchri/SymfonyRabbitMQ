{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Symfony 4 & Rabbitmq A minimal project combining Symfony 4 and Rabbitmq. The Big Picture This application uses the Symfony 4 framework in order to exchange data with a message broker. The message broker is implemented by a third party, using RabbitMQ and credentials are provided in order to publish/consume messages to/from it. Data which are included in each message, are provided by a third party API. The Symfony Messenger Component is used in order to send and consume messages to and from rabbitmq. Each time a message is consumed a new doctrine Entity, type of Net2Grid, is created parameterized according to message contents. Finally, the new entity is used, in order to save this information in a mysql database. Requirements In order to install this application, your system must fulfill these requirements: Docker version 19.03.5 or higher Running the application Using docker is really easy to start a producer and a consumer service. Open a terminal and cd in the project folder (where the Dockerfile-producer & Dockerfile-consumer exist). Start by building the necessary images (skip if already done): docker image build -t chris-consumer-img -f Dockerfile-consumer . docker image build -t chris-producer-img -f Dockerfile-producer . Then start two containers in the background: docker run --restart=always -d -p 8010:8000 chris-consumer-img:latest docker run -d -p 8001:8000 chris-producer-img:latest Great! Both worker that consumes messages and a producer has start. The producer exposes an endpoint, where you may use in order to sent messages to the queue. Open a browser and head to localhost:8001/basic in order to send a single message to the queue, or head to localhost:8001/basic/{num: int} in order to send multiple messages. A valid url would be localhost:8001/basic/10 and visiting it would result 10 messages to be produced and sent to the queue. Queue will accept some of them, based on the rooting key used. Each time new messages arrive at it, the consumer consumes it and saves it to a database. Warning A consumer container may to fail after some amount of time. Since we are not using a container orchestration tool, user is responsible for manually restarting it. In order to avoid such situations, the --restart=always argument is provided to the docker run command that starts the consumer's container. Important This application is only a demo for demonstration purposes. It is not configured for production. Documentation Documentation files. which are used to build the current site, can be found at this github repository under the docs/ directory. If you wish to edit the docs, cd into the docs/ directory and run: make serve-docs This command will start a local development server, which can be used to render the edited docs, in realtime. If you wish to build the docs into a static website, ready for deployment in heroku, just run: make build-docs This command will create a new folder, named sites/, under the docs/ directory. You may use the following command in order to deploy to heroku, or deploy to another provider. git push heroku `git subtree split --prefix docs/site master`:master --force Warning In order to start the development server, or build the docs both python 3 and pipenv must be installed in your system.","title":"Overview"},{"location":"#symfony-4-rabbitmq","text":"A minimal project combining Symfony 4 and Rabbitmq.","title":"Symfony 4 &amp; Rabbitmq"},{"location":"#the-big-picture","text":"This application uses the Symfony 4 framework in order to exchange data with a message broker. The message broker is implemented by a third party, using RabbitMQ and credentials are provided in order to publish/consume messages to/from it. Data which are included in each message, are provided by a third party API. The Symfony Messenger Component is used in order to send and consume messages to and from rabbitmq. Each time a message is consumed a new doctrine Entity, type of Net2Grid, is created parameterized according to message contents. Finally, the new entity is used, in order to save this information in a mysql database.","title":"The Big Picture"},{"location":"#requirements","text":"In order to install this application, your system must fulfill these requirements: Docker version 19.03.5 or higher","title":"Requirements"},{"location":"#running-the-application","text":"Using docker is really easy to start a producer and a consumer service. Open a terminal and cd in the project folder (where the Dockerfile-producer & Dockerfile-consumer exist). Start by building the necessary images (skip if already done): docker image build -t chris-consumer-img -f Dockerfile-consumer . docker image build -t chris-producer-img -f Dockerfile-producer . Then start two containers in the background: docker run --restart=always -d -p 8010:8000 chris-consumer-img:latest docker run -d -p 8001:8000 chris-producer-img:latest Great! Both worker that consumes messages and a producer has start. The producer exposes an endpoint, where you may use in order to sent messages to the queue. Open a browser and head to localhost:8001/basic in order to send a single message to the queue, or head to localhost:8001/basic/{num: int} in order to send multiple messages. A valid url would be localhost:8001/basic/10 and visiting it would result 10 messages to be produced and sent to the queue. Queue will accept some of them, based on the rooting key used. Each time new messages arrive at it, the consumer consumes it and saves it to a database. Warning A consumer container may to fail after some amount of time. Since we are not using a container orchestration tool, user is responsible for manually restarting it. In order to avoid such situations, the --restart=always argument is provided to the docker run command that starts the consumer's container. Important This application is only a demo for demonstration purposes. It is not configured for production.","title":"Running the application"},{"location":"#documentation","text":"Documentation files. which are used to build the current site, can be found at this github repository under the docs/ directory. If you wish to edit the docs, cd into the docs/ directory and run: make serve-docs This command will start a local development server, which can be used to render the edited docs, in realtime. If you wish to build the docs into a static website, ready for deployment in heroku, just run: make build-docs This command will create a new folder, named sites/, under the docs/ directory. You may use the following command in order to deploy to heroku, or deploy to another provider. git push heroku `git subtree split --prefix docs/site master`:master --force Warning In order to start the development server, or build the docs both python 3 and pipenv must be installed in your system.","title":"Documentation"},{"location":"deleteMe/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. lela lealea My Section lela - lala","title":"Welcome to MkDocs"},{"location":"deleteMe/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"deleteMe/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"deleteMe/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. lela lealea","title":"Project layout"},{"location":"deleteMe/#my-section","text":"lela - lala","title":"My Section"},{"location":"internals/","text":"Application's Internals This section provides an extensive look at application's classes and how these are combined together to provide the desired functionality. Producing Messages In order to produce and publish messages to the queue, the following process is necessary. Several classes are involved in the process: BasicController BasicController exposes an endpoint at /basic/{num_of_messages: int} . Each time a request to this endpoint occurs, Symfony makes sure that BasicController.index() is invoked. There, the controller uses the requestHandler-> sendRequest() function, in order to receive a message (type of array) and a rooting key (type of string). The requestHandler is a RequestHandler instance. Then, controller uses the function dispatch() , provided by Symfony Messernger Component, in order to sent the message to the queue. The process is repeated for num_of_messages times. If num_of_messages is not specified, it is considered to be equal to 1. RequestHandler RequestHandler exposes a public method named sendRequest . Each time sendRequest() is invoked, a GET request is sent at https://a831bqiv1d.execute-api.eu-west-1.amazonaws.com/dev/results . The response is forwarded to a RequestSerializer instance, in order to construct a message object, type of MyMessage and a rooting key, type of string. Both the message and the rooting key are returned as function's result, to BasicController . RequestSerializer RequestSerializer is responsible for de-serialization of responses, received by RequestHandler . Each response has the following format: { gatewayEui: string, profileId: string, endpointId: string, clusterId: string, attributeId: string, value: int, timestamp: int } The RequestSerializer will turn such a response into a message: MyMessage instance and a rooting key: string . The rooting key has the form: <gateway eui>.<profile>.<endpoint>.<cluster>.<attribute> and is created by the decimal value of the corresponding values in respone object. The convertion from string to decimal is achieved using the php build-in function hex2dec_string . MyMessage MyMessage is a common php class which defines the data that each queue message contains. MyMessage has the following attributes: value int timestamp int rootingKey string In our messenger.yaml file, we have already defined that MyMessage class will be used for rooting by our tranports. Thus, Symfony Component Messenger knows that it should sent a MyMessage object to the queue. Additionally, when consuming a message type of MyMessage , it tries to invoke a proper handler function. Consuming Messages In order to consume messages from the queue we need a properly defined class. This class should implement the Symfony\\Component\\Messenger\\Handler\\MessageHandlerInterface . In this application the corresponding class is named MyMessageHandler . MyMessageHandler MyMessageHandler is a class that implements Symfony\\Component\\Messenger\\Handler\\MessageHandlerInterface . Here we override the __invoke( MyMessage $msg ) , in order to define how to handle a message each time it is consumed. In our cases, a consumed message's attributes are used in order to create a Net2Grid object, which allows us to store those data in the database. Note Note that all we need to do, is declare that the __invoke function accepts as argument a MyMessage object. This way the Symfony Messenger Component knows to use this specific handler each time a message arrives in the Bus, in order to be consumed. Net2Grid Net2Grid is a doctrine ORM Entity used to easily save data to the database. The Entity has the following attributes: id ID gatewaiUi STRING profile STRING endpoint STRING cluster STRING attribute STRING value BIGINT timestamp BIGINT Declaring Additional Services Since BasicController uses an instance type of RequestHandler and RequestHandler uses an instance type of RequestSerializer , we should add the following lines in our services.yaml file. # add more service definitions when explicit configuration is needed App\\Controller\\BasicController: ['@App\\Service\\RequestHandler'] App\\Service\\RequestHandler: ['@App\\Serializer\\RequestSerializer']","title":"Application's Internals"},{"location":"internals/#applications-internals","text":"This section provides an extensive look at application's classes and how these are combined together to provide the desired functionality.","title":"Application's Internals"},{"location":"internals/#producing-messages","text":"In order to produce and publish messages to the queue, the following process is necessary. Several classes are involved in the process:","title":"Producing Messages"},{"location":"internals/#basiccontroller","text":"BasicController exposes an endpoint at /basic/{num_of_messages: int} . Each time a request to this endpoint occurs, Symfony makes sure that BasicController.index() is invoked. There, the controller uses the requestHandler-> sendRequest() function, in order to receive a message (type of array) and a rooting key (type of string). The requestHandler is a RequestHandler instance. Then, controller uses the function dispatch() , provided by Symfony Messernger Component, in order to sent the message to the queue. The process is repeated for num_of_messages times. If num_of_messages is not specified, it is considered to be equal to 1.","title":"BasicController"},{"location":"internals/#requesthandler","text":"RequestHandler exposes a public method named sendRequest . Each time sendRequest() is invoked, a GET request is sent at https://a831bqiv1d.execute-api.eu-west-1.amazonaws.com/dev/results . The response is forwarded to a RequestSerializer instance, in order to construct a message object, type of MyMessage and a rooting key, type of string. Both the message and the rooting key are returned as function's result, to BasicController .","title":"RequestHandler"},{"location":"internals/#requestserializer","text":"RequestSerializer is responsible for de-serialization of responses, received by RequestHandler . Each response has the following format: { gatewayEui: string, profileId: string, endpointId: string, clusterId: string, attributeId: string, value: int, timestamp: int } The RequestSerializer will turn such a response into a message: MyMessage instance and a rooting key: string . The rooting key has the form: <gateway eui>.<profile>.<endpoint>.<cluster>.<attribute> and is created by the decimal value of the corresponding values in respone object. The convertion from string to decimal is achieved using the php build-in function hex2dec_string .","title":"RequestSerializer"},{"location":"internals/#mymessage","text":"MyMessage is a common php class which defines the data that each queue message contains. MyMessage has the following attributes: value int timestamp int rootingKey string In our messenger.yaml file, we have already defined that MyMessage class will be used for rooting by our tranports. Thus, Symfony Component Messenger knows that it should sent a MyMessage object to the queue. Additionally, when consuming a message type of MyMessage , it tries to invoke a proper handler function.","title":"MyMessage"},{"location":"internals/#consuming-messages","text":"In order to consume messages from the queue we need a properly defined class. This class should implement the Symfony\\Component\\Messenger\\Handler\\MessageHandlerInterface . In this application the corresponding class is named MyMessageHandler .","title":"Consuming Messages"},{"location":"internals/#mymessagehandler","text":"MyMessageHandler is a class that implements Symfony\\Component\\Messenger\\Handler\\MessageHandlerInterface . Here we override the __invoke( MyMessage $msg ) , in order to define how to handle a message each time it is consumed. In our cases, a consumed message's attributes are used in order to create a Net2Grid object, which allows us to store those data in the database. Note Note that all we need to do, is declare that the __invoke function accepts as argument a MyMessage object. This way the Symfony Messenger Component knows to use this specific handler each time a message arrives in the Bus, in order to be consumed.","title":"MyMessageHandler"},{"location":"internals/#net2grid","text":"Net2Grid is a doctrine ORM Entity used to easily save data to the database. The Entity has the following attributes: id ID gatewaiUi STRING profile STRING endpoint STRING cluster STRING attribute STRING value BIGINT timestamp BIGINT","title":"Net2Grid"},{"location":"internals/#declaring-additional-services","text":"Since BasicController uses an instance type of RequestHandler and RequestHandler uses an instance type of RequestSerializer , we should add the following lines in our services.yaml file. # add more service definitions when explicit configuration is needed App\\Controller\\BasicController: ['@App\\Service\\RequestHandler'] App\\Service\\RequestHandler: ['@App\\Serializer\\RequestSerializer']","title":"Declaring Additional Services"},{"location":"settings/","text":"Configuring Symfony with RabbitMQ & Doctrine This section describes the necessary configuration of a Symfony 4 project, in order to use it along with a RabbitMQ and an Object relational mapper (ORM), known as Doctrine. Symfony 4 Project Structure When building a new Symfony 4 project using the command: symfony new <project_name> a folder named is created, having the project structure as shown in the following figure: In order to combine with RabbitMQ we use the Symfony Messenger Component. Messenger provides a message bus with the ability to send messages and then handle them immediately in your application or send them through transports (e.g. queues) to be handled later. Also, using the Doctrine ORM requires the doctrine-orm bundle. The following commands may be used to install the necessary bundles: composer require symfony/messenger composer require symfony/orm-pack Note Installing those bundles is not necessary to run this application, since dockerfiles take care of it on your behalf. After installing those bundles, the project structure includes some extra files. In the figure below part of the project structure is shown, where we highlight (with green color), the files that must be configured. Configuring the .env file Communication with the RabbitMQ queue should be done using the following credentials: hostname: candidatemq.n2g-dev.net username: cand_d4uf password: Yd6bCNQgWpx429zr exchange: cand_d4uf queue: cand_d4uf_results Therefore, our .env file should include the following lines: ###> symfony/messenger ### MESSENGER_TRANSPORT_DSN=amqp://cand_d4uf:Yd6bCNQgWpx429zr@candidatemq.n2g-dev.net ###< symfony/messenger ### Configuring the messenger.yaml file This is a file that must be configured when using Symfony's Messenger to exchange messages with RabbitMQ. The figure below displays the big picture of message exchange between a Symfony application and a RabbitMQ queue: A message Producer sends the message to an exchange, along with a rooting key. An exchange is connected to one or more queues, using a binding and a binding key. When a message arrives at the exchange, it compares the rooting key with each binding key and forwards the message to the corresponding queue. The way an exchange compares a rooting key with a binding key depends on the type of the exchange (e.g. direct). If messages exist in a queue, they may be consumed by one or more consumers. When using the Symfony Messenger Component a message bus is provided. Using it, we have the ability to send messages and then handle them immediately in our application or send them through transports (e.g. queues) to be handled later. Messenger supports a number of different transport types, each with their own options. Since we need to use RabbitMQ we need to configure the AMQP Transport. In order to do so, we configure the messenger.yaml as shown below: framework: messenger: # Uncomment this (and the failed transport below) to send failed messages # to this transport for later handling. # failure_transport: failed transports: # https://symfony.com/doc/current/messenger.html#transport-configuration async: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: auto_setup: false # for AMQP send to a separate exchange then queue exchange: name: cand_d4uf type: direct consumer_transport: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: auto_setup: false queues: cand_d4uf_results: ~ # -> If you wish to use custom serializer for this transport, # uncomment the next line: # serializer: App\\Serializer\\ExternalJsonSerializer routing: # Route your messages to the transports 'App\\Message\\MyMessage' : [async, consumer_transport] # -> If you wish to use custom serializer for this transport, # remove the 'consumer_transport' from the array above. Note Using different transports we are able to define custom serializer for messages that will be published or consumed. We need to define custom serializer if we consume messages from the queue, which are created by a third party. Configuring the services.yaml file With Doctrine, saving entities to the database is easy, since the Doctrine's object manager works on our behalf. But in order to use it, we need to declare it as a service, so it can be autowired by Symfony. Thus, our services.yaml file should include the following lines: # add more service definitions when explicit configuration is needed Doctrine\\Persistence\\ObjectManager: '@doctrine.orm.default_entity_manager'","title":"Configuring Symfony"},{"location":"settings/#configuring-symfony-with-rabbitmq-doctrine","text":"This section describes the necessary configuration of a Symfony 4 project, in order to use it along with a RabbitMQ and an Object relational mapper (ORM), known as Doctrine.","title":"Configuring Symfony with RabbitMQ &amp; Doctrine"},{"location":"settings/#symfony-4-project-structure","text":"When building a new Symfony 4 project using the command: symfony new <project_name> a folder named is created, having the project structure as shown in the following figure: In order to combine with RabbitMQ we use the Symfony Messenger Component. Messenger provides a message bus with the ability to send messages and then handle them immediately in your application or send them through transports (e.g. queues) to be handled later. Also, using the Doctrine ORM requires the doctrine-orm bundle. The following commands may be used to install the necessary bundles: composer require symfony/messenger composer require symfony/orm-pack Note Installing those bundles is not necessary to run this application, since dockerfiles take care of it on your behalf. After installing those bundles, the project structure includes some extra files. In the figure below part of the project structure is shown, where we highlight (with green color), the files that must be configured.","title":"Symfony 4 Project Structure"},{"location":"settings/#configuring-the-env-file","text":"Communication with the RabbitMQ queue should be done using the following credentials: hostname: candidatemq.n2g-dev.net username: cand_d4uf password: Yd6bCNQgWpx429zr exchange: cand_d4uf queue: cand_d4uf_results Therefore, our .env file should include the following lines: ###> symfony/messenger ### MESSENGER_TRANSPORT_DSN=amqp://cand_d4uf:Yd6bCNQgWpx429zr@candidatemq.n2g-dev.net ###< symfony/messenger ###","title":"Configuring the .env file"},{"location":"settings/#configuring-the-messengeryaml-file","text":"This is a file that must be configured when using Symfony's Messenger to exchange messages with RabbitMQ. The figure below displays the big picture of message exchange between a Symfony application and a RabbitMQ queue: A message Producer sends the message to an exchange, along with a rooting key. An exchange is connected to one or more queues, using a binding and a binding key. When a message arrives at the exchange, it compares the rooting key with each binding key and forwards the message to the corresponding queue. The way an exchange compares a rooting key with a binding key depends on the type of the exchange (e.g. direct). If messages exist in a queue, they may be consumed by one or more consumers. When using the Symfony Messenger Component a message bus is provided. Using it, we have the ability to send messages and then handle them immediately in our application or send them through transports (e.g. queues) to be handled later. Messenger supports a number of different transport types, each with their own options. Since we need to use RabbitMQ we need to configure the AMQP Transport. In order to do so, we configure the messenger.yaml as shown below: framework: messenger: # Uncomment this (and the failed transport below) to send failed messages # to this transport for later handling. # failure_transport: failed transports: # https://symfony.com/doc/current/messenger.html#transport-configuration async: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: auto_setup: false # for AMQP send to a separate exchange then queue exchange: name: cand_d4uf type: direct consumer_transport: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: auto_setup: false queues: cand_d4uf_results: ~ # -> If you wish to use custom serializer for this transport, # uncomment the next line: # serializer: App\\Serializer\\ExternalJsonSerializer routing: # Route your messages to the transports 'App\\Message\\MyMessage' : [async, consumer_transport] # -> If you wish to use custom serializer for this transport, # remove the 'consumer_transport' from the array above. Note Using different transports we are able to define custom serializer for messages that will be published or consumed. We need to define custom serializer if we consume messages from the queue, which are created by a third party.","title":"Configuring the messenger.yaml file"},{"location":"settings/#configuring-the-servicesyaml-file","text":"With Doctrine, saving entities to the database is easy, since the Doctrine's object manager works on our behalf. But in order to use it, we need to declare it as a service, so it can be autowired by Symfony. Thus, our services.yaml file should include the following lines: # add more service definitions when explicit configuration is needed Doctrine\\Persistence\\ObjectManager: '@doctrine.orm.default_entity_manager'","title":"Configuring the services.yaml file"},{"location":"structure/","text":"Project Structure The following figure shows part of the project structure, which contains several new classes. Each class has a specific responsibility, e.g. consuming data from an API, serializing the data, creating messages, etc. More details about the specific use of each class is provided in section Application's Internals . In this section we discuss about the functionality and the porpuse of classes inside these directories. Each directory under the src/ is used to define a group of classes, which have common functionality. Controller This directory contains classes that act as controllers. This directory contains classes that act as controllers. Controllers are used to decoupling classes and increase reusability. In Symfony, each controller may contain several methods bound to different endpoints, using annotations, which handle requests to the corresponding endpoints. Message This directory contains classes that define the form of the messages, that will be sent to and received from the queue. MessageHandler This directory contains classes whose purpose is to define how consumed messages will be handled. In order to achieve such behavior, each class must implements the Symfony\\Component\\Messenger\\Handler\\MessageHandlerInterface and thus, it must override the __invoke method. Each class in this directory is bound to a class under Message directory. Defining such a binding in Symfony 4 is really easy, since it is defined by the type of the argument provided in the __invoke function. Serializer This directory contains classes that are used for abstracting the serialization, or de-serialization, of json objects, arrays, php objects, etc. Service This directory contains classes which provide a specific and reusable functionality. Entity This directory contains classes that represent Doctrine entities and are used for easying integration with the database. Repository This directory is auto-updated by Doctrine. Migrations This directory is auto-updated by Doctrine. It contains migrations which can be used to update the database without using raw sql queries.","title":"Project Structure"},{"location":"structure/#project-structure","text":"The following figure shows part of the project structure, which contains several new classes. Each class has a specific responsibility, e.g. consuming data from an API, serializing the data, creating messages, etc. More details about the specific use of each class is provided in section Application's Internals . In this section we discuss about the functionality and the porpuse of classes inside these directories. Each directory under the src/ is used to define a group of classes, which have common functionality.","title":"Project Structure"},{"location":"structure/#controller","text":"This directory contains classes that act as controllers. This directory contains classes that act as controllers. Controllers are used to decoupling classes and increase reusability. In Symfony, each controller may contain several methods bound to different endpoints, using annotations, which handle requests to the corresponding endpoints.","title":"Controller"},{"location":"structure/#message","text":"This directory contains classes that define the form of the messages, that will be sent to and received from the queue.","title":"Message"},{"location":"structure/#messagehandler","text":"This directory contains classes whose purpose is to define how consumed messages will be handled. In order to achieve such behavior, each class must implements the Symfony\\Component\\Messenger\\Handler\\MessageHandlerInterface and thus, it must override the __invoke method. Each class in this directory is bound to a class under Message directory. Defining such a binding in Symfony 4 is really easy, since it is defined by the type of the argument provided in the __invoke function.","title":"MessageHandler"},{"location":"structure/#serializer","text":"This directory contains classes that are used for abstracting the serialization, or de-serialization, of json objects, arrays, php objects, etc.","title":"Serializer"},{"location":"structure/#service","text":"This directory contains classes which provide a specific and reusable functionality.","title":"Service"},{"location":"structure/#entity","text":"This directory contains classes that represent Doctrine entities and are used for easying integration with the database.","title":"Entity"},{"location":"structure/#repository","text":"This directory is auto-updated by Doctrine.","title":"Repository"},{"location":"structure/#migrations","text":"This directory is auto-updated by Doctrine. It contains migrations which can be used to update the database without using raw sql queries.","title":"Migrations"},{"location":"using/","text":"Using the Application Not production ready Workers at production https://symfony.com/doc/current/messenger.html#deploying-to-production","title":"Using the Application"},{"location":"using/#using-the-application","text":"","title":"Using the Application"},{"location":"using/#not-production-ready","text":"","title":"Not production ready"},{"location":"using/#workers-at-production","text":"https://symfony.com/doc/current/messenger.html#deploying-to-production","title":"Workers at production"}]}